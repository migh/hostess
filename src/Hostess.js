const os = require('os');
const fs = require('fs');
const path = require('path');

const utils = require('./utils');

class Hostess {
  constructor(options) {
    const { platform, homedir, arch, hosts } = this.getPlatforminfo();
    this.__ = { platform, homedir, arch, hosts };
    if (options && options.basedir) {
      this.__.basedir = options.basedir;
    } else {
      if (require.main === module) {
        this.__.basedir = __dirname;
      } else {
        this.__.basedir = path.parse(require.main.filename).dir;
      }
    }
  }

  getPlatforminfo() {
    const systemSpecific = {
      linux: {
        hosts: path.parse('/etc/hosts')
      },
      darwin: {
        hosts: path.parse('/etc/hosts')
      },
      win32: {
        hosts: path.parse('C:\\windows\\system32\\drivers\\etc\\hosts')
      }
    };

    return {
      platform: os.platform(),
      homedir: os.homedir(),
      arch: os.arch(),
      hosts: systemSpecific[os.platform()].hosts
    };
  }

  map(domains, map, options) {
    try {
      const domainsLines = utils.loadFile(path.join(this.__.basedir, domains));
      const domainsMap = require(path.join(this.__.basedir, map));
      const domainsList = Object.keys(domainsMap);

      let hostLines = ['\n# Generated by Hostess'];
      let hostsOut;

      hostLines = hostLines.concat(domainsLines.map( domain => {
        if (domainsList.includes(domain)) {
          return `${domainsMap[domain]}\t${domain}`;
        } else {
          return (domainsList.includes('*')) ? `${domainsMap['*']}\t${domain}`: null;
        }
      }).filter( ln => !(ln === null)));

      if (options.append) {
        hostsOut = this.getHostInfo(true);
        hostsOut += hostLines.join('\n');
      }

      if (options.outputfile) {
        utils.writeFile(path.join(this.__.basedir, options.outputfile), hostsOut);
      } if (options.writeHosts) {
        utils.writeFile(path.format(this.__.hosts), hostsOut);
      } else {
        console.log(hostsOut);
      }
    } catch(e) {
      if (e.code === 'ENOENT') {
        const file = path.parse(e.path);
        console.error(`File "${file.name}" was not found in "${file.dir}" directory.`);
        return;
      }
      if (e.code === 'EACCES') {
        const file = path.parse(e.path);
        console.error(`File "${file.name}" in "${file.dir}" directory cannot be edited.`);
        console.error('You probably need to use sudo.');
        return;
      }
      console.error(e);
    }
  }

  getHostInfo(raw) {
    const currentHostsFile = fs.readFileSync(path.format(this.__.hosts), { encoding: 'utf-8' });

    if (raw) {
      return currentHostsFile;
    }

    const obj = {};
    const defs = currentHostsFileLines.split('\n').filter( ln => !(ln === '' || ln.match(/^#/)))
      .map( ln => ln.split(/\s+/))
      .map( ln => ({ host: ln[0], domains: ln.slice(1) }));

    defs.forEach( hst => {
      if (obj[hst.host]) {
        obj[hst.host].concat(hst.domains);
      } else {
        obj[hst.host] = hst.domains;
      }
    });
    return obj;
  }
}

module.exports = Hostess;
